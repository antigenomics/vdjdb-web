# This is the main configuration file for the application.
# ~~~~~

# Secret key
# ~~~~~
# The secret key is used to secure cryptographics functions.
#
# This must be changed for production, but we recommend not changing it in this file.
#
# See http://www.playframework.com/documentation/latest/ApplicationSecret for more details.
play.http.secret.key = "2sh8?@C_pHH2M1JXSchxdu=w;kEbgO_3EggRGyJM0YlrX:a;YJBsYhR56V0Nmi;X"
play.http.secret.key = ${?VDJDB_APPLICATION_SECRET}

play.http.errorHandler = "backend.controllers.ErrorsHandler"
play.http.session.cookie.secure = true

# The application languages
# ~~~~~
play.i18n.langs = ["en"]


# The application configuration

#Path to store application.log
loggerPath = ./logs

application {

  #TemporaryFileProvider configuration
  temporary {
    #Path to store temporary files
    path = "/tmp/vdjdb-temporary",
    #Specify the time during which the file is guaranteed to be exist
    keep = 600,
    #Specify an interval for deleting expired temporary files
    interval = 600
  }

  #VDJdb-db configuration
  database {
    #Specify if use local vdjdb-database or try to download latest release from github repository
    useLocal = true
    #Specify path to local vdjdb-database
    path = "database/"
  }

  # Authorization configuration
  auth {
    #Verification token configuration
    verification {
      #Specify the time during which the token is guaranteed to be valid
      keep = 600,
      #Specify an interval for deleting expired tokens
      interval = 600
    }
  }

  # Analytics configuration
  analytics {
    yandexID = "none"
    yandexID = ${?VDJDB_APPLICATION_ANALYTICS_YANDEX_ID}
    googleID = "none"
    googleID = ${?VDJDB_APPLICATION_ANALYTICS_GOOGLE_ID}
  }

}

# Router
# ~~~~~
# Define the Router object to use for this application.
# This router will be looked up first when the application is starting up,
# so make sure this is the entry point.
# Furthermore, it's assumed your route file is named properly.
# So for an application router like `my.application.Router`,
# you may need to define a router file `conf/my.application.routes`.
# Default to Routes in the root package (and conf/routes)
# play.http.router = my.application.Routes

# Database configuration
# ~~~~~
# By convention, the default datasource is named `default`
#
slick.dbs.default.profile = "slick.jdbc.H2Profile$"
slick.dbs.default.db.profile = "org.h2.Driver"
slick.dbs.default.db.url = "jdbc:h2:mem:play;DB_CLOSE_DELAY=-1"
play.evolutions.db.default.autoApply = true

# play.evolutions.enabled=false

fixedConnectionPool = 9
database.dispatcher {
  executor = "thread-pool-executor"
  throughput = 1
  thread-pool-executor {
    fixed-pool-size = ${fixedConnectionPool}
  }
}

play.modules {
  enabled += "play.filters.headers.SecurityHeadersModule"
  enabled += "play.filters.gzip.GzipFilterModule"
}

play.filters {

  enabled = [
    play.filters.csrf.CSRFFilter,
    play.filters.headers.SecurityHeadersFilter,
    play.filters.gzip.GzipFilter,
    backend.server.limit.RequestLimits
  ]

  headers {

    # The X-Frame-Options header. If null, the header is not set.
    frameOptions = "DENY"

    # The X-XSS-Protection header. If null, the header is not set.
    xssProtection = "1; mode=block"

    # The X-Content-Type-Options header. If null, the header is not set.
    contentTypeOptions = "nosniff"

    # The X-Permitted-Cross-Domain-Policies header. If null, the header is not set.
    permittedCrossDomainPolicies = "master-only"

    # Content-Security-Policy
    # You may want to change this for production environments.
    # In dev mode is used to allow Webpack Webesockets for auto reloads
    //contentSecurityPolicy = "default-src 'self'"
    contentSecurityPolicy = null

    # The Referrer-Policy header. If null, the header is not set.
    referrerPolicy = "origin-when-cross-origin, strict-origin-when-cross-origin"

    # If true, allow an action to use .withHeaders to replace one or more of the above headers
    allowActionSpecificHeaders = false
  }

  gzip {

    contentType {

      # If non empty, then a response will only be compressed if its content type is in this list.
      whiteList = ["text/*", "application/javascript", "application/json"]

      # The black list is only used if the white list is empty.
      # Compress all responses except the ones whose content type is in this list.
      blackList = []
    }

    # The buffer size to use for gzipped bytes
    bufferSize = 8k

    # The maximum amount of content to buffer for gzipping in order to calculate the content length before falling back
    # to chunked encoding.
    chunkedThreshold = 100000k

  }

  limits {
    maxRequestsCount = 10000  # int
    countClearInterval = 3600 # seconds
    maxRequestsTime = 900000  # milliseconds
    timeClearInterval = 1800  # seconds
  }

}